<h2><span>Help &raquo; Manual &raquo;<br>Chapter 3: Extending nanoc</span></h2>

<p><a href="/help/manual/">&laquo; Back to the Manual Table of Contents</a></p>

<p>nanoc is quite customizable. Apart from being able to write arbitrary code that is executed before a site is compiled, it is also possible to write custom (binary) filters, data sources and routers.</p>

<div class="section" id="writing-data-sources">
	<h3><span>Writing Data Sources</span></h3>

	<p>A data source is responsible for loading and storing a site's data: pages, page defaults, assets, asset defaults, templates, layouts and code.</p>

	<p>Data sources are classes that inherit from <code>Nanoc::DataSource</code>. There is no need to explicitly register data source classes; nanoc will find all data source classes automatically.</p>

	<p>Each data source has an identifier. This is a unique name that is used in a site's configuration file to specify which data source should be used to fetch data. It is specified like this:</p>

	<pre><code><span class="keyword">class</span> <span class="storage">SampleDataSource</span> &lt; <span class="storage">Nanoc::DataSource</span>
  <span class="function">identifier</span> <span class="symbol">:sample</span>
<span class="keyword">end</span></code></pre>

	<p>All methods in the data source have access to the <code>@site</code> object, which represents the site. One useful thing that can be done with this is request the configuration hash, using <code>@site.config</code>.</p>

	<div class="section" id="writing-data-sources-preparation">
		<h4><span>Preparation</span></h4>

		<p>There are two methods you may want to implement first: <code>up</code> and <code>down</code>. <code>up</code> is executed when the data source is loaded. For example, this would be the ideal place to establish a connection to the database. <code>down</code> is executed when the data source is unloaded, so this is the ideal place to undo what <code>up</code> did.</p>

		<p>The <code>setup</code> method is used to create the initial site structure. For example, a database data source could create the necessary tables here. The <code>destroy</code> method should do the opposite of what <code>setup</code> does. For example, a database data source would drop the created tables in this method.</p>

		<p>The <code>update</code> method is used for updating the format in which the data is stored. For example, a database data source could add necessary new columns here.</p>

		<p>None of these methods need to be implemented; you can simply leave the method definitions out.</p>
	</div>

	<div class="section" id="writing-data-sources-functions">
		<h4><span>Functions</span></h4>

		<p>The following methods (grouped by data type) are required to be implemented by any data source:</p>

		<dl class="nested">
			<dt>Pages &mdash; <code>Nanoc::Page</code></dt>
			<dd>
				<ul>
					<li><code>pages()</code></li>
					<li><code>save_page(page)</code></li>
					<li><code>move_page(page, new_path)</code></li>
					<li><code>destroy_page(page)</code></li>
				</ul>
			</dd>
			<dt>Page Defaults (singular) &mdash; <code>Nanoc::PageDefaults</code></dt>
			<dd>
				<ul>
					<li><code>page_defaults()</code></li>
					<li><code>save_page_defaults(page_defaults)</code></li>
				</ul>
			</dd>
			<dt>Assets &mdash; <code>Nanoc::Asset</code></dt>
			<dd>
				<ul>
					<li><code>assets()</code></li>
					<li><code>save_asset(asset)</code></li>
					<li><code>move_asset(asset, new_path)</code></li>
					<li><code>destroy_asset(asset)</code></li>
				</ul>
			</dd>
			<dt>Asset Defaults (singular) &mdash; <code>Nanoc::AssetDefaults</code></dt>
			<dd>
				<ul>
					<li><code>asset_defaults()</code></li>
					<li><code>save_asset_defaults(asset_defaults)</code></li>
				</ul>
			</dd>
			<dt>Layouts &mdash; <code>Nanoc::AssetDefaults</code></dt>
			<dd>
				<ul>
					<li><code>layouts()</code></li>
					<li><code>save_layout(layout)</code></li>
					<li><code>move_layout(layout, new_path)</code></li>
					<li><code>destroy_layout(layout)</code></li>
				</ul>
			</dd>
			<dt>Templates &mdash; <code>Nanoc::Template</code></dt>
			<dd>
				<ul>
					<li><code>templates()</code></li>
					<li><code>save_template(template)</code></li>
					<li><code>move_template(template, new_path)</code></li>
					<li><code>destroy_template(template)</code></li>
				</ul>
			</dd>
			<dt>Code (singular) &mdash; <code>Nanoc::Code</code></dt>
			<dd>
				<ul>
					<li><code>code()</code></li>
					<li><code>save_code(code)</code></li>
				</ul>
			</dd>
		</dl>

		<p>The "singular" indicates that there is only one resource of the specified kind. Such resources therefore lack <code>move_x</code> and <code>destroy_x</code> functions, as they cannot be moved nor destroyed.</p>

		<p>The class name next to each data type is the object type that is passed to functions or is returned from functions. For example, the <code>save_page</code> function will get a <code>Nanoc::Page</code> while the <code>layouts</code> function will return an array of <code>Nanoc::Layout</code>s.</p>

		<p>The loading functions (<code>pages</code>, <code>page_defaults</code>, &hellip;) should return an array of objects, or, if the resource is singular, a single object. These functions do not take any parameters.</p>

		<p>The saving functions (<code>save_page</code>, <code>save_page_defaults</code>, &hellip;) should store the given object. The argument is the object to be stored.</p>

		<p>The moving functions (<code>move_page</code>, &hellip;) should change the given object's name or path. The first argument is the object to be moved, while the second argument is the new path or new name.</p>

		<p>The destroying functions (<code>destroy_page</code>, &hellip;) should delete the given object. The argument is the object to be destroyed.</p>

		<p>If all this sounds a bit vague and weird, do check out the source of a data source, and the documentation of <code>Nanoc::DataSource</code> itself. The code is well-documented and should help you to get started quickly.</p>
	</div>
</div>

<div class="section" id="writing-filters">
	<h3><span>Writing Filters</span></h3>

	<p>Filters are classes that inherit from <code>Nanoc::Filter</code>. They do not need to be explicitly registered; nanoc will find filter classes automatically.</p>

	<p>A filter has an identifier, which is an unique name that is used in a page's list of filters. It is set like this:</p>

	<pre><code><span class="keyword">class</span> <span class="storage">CensorFilter</span> &lt; <span class="storage">Nanoc::Filter</span>
  <span class="function">identifier</span> <span class="symbol">:censor</span>
<span class="keyword">end</span></code></pre>

	<p>A filter can have multiple identifiers. Specify multiple identifiers using <code>identifiers</code> instead of <code>identifier</code>, like this:</p>

	<pre><code><span class="keyword">class</span> <span class="storage">CensorFilter</span> &lt; <span class="storage">Nanoc::Filter</span>
  <span class="function">identifiers</span> <span class="symbol">:censor</span>, <span class="symbol">:stop_the_hate</span>
<span class="keyword">end</span></code></pre>

	<p>A filter needs to implement only one method, <code>run</code>. This method takes the unfiltered content as its only argument, and returns the filtered content. For example:</p>

	<pre><code><span class="keyword">def</span> <span class="function">run</span>(<span class="variable">content</span>)
  <span class="variable">content</span>.<span class="function">gsub</span>(<span class="string">'nanoc sucks'</span>, <span class="string">'nanoc rocks'</span>)
<span class="keyword">end</span></code></pre>

	<p>The filter has access to several useful instance variables:</p>
	
	<dl>
		<dt><code>@page_rep</code></dt>
		<dd>Contains the page representation that is being filtered.</dd>

		<dt><code>@page</code></dt>
		<dd>Contains the current page.</dd>

		<dt><code>@asset_rep</code></dt>
		<dd>Contains the asset representation that is being filtered.</dd>

		<dt><code>@asset</code></dt>
		<dd>Contains the current asset.</dd>

		<dt><code>@site</code></dt>
		<dd>Contains the site.</dd>
	</dl>
</div>

<div class="section" id="writing-binary-filters">
	<h3><span>Writing Binary Filters</span></h3>

	<p>Binary filters are very similar to <a href="#writing-filters">normal filters</a>, except that they work with File objects instead of actual content. They inherit from <code>Nanoc::BinaryFilter</code>.</p>

	<p>Just like with normal filters, binary filters can have one or more identifiers, and they do not need to be registered explicitly.</p>

	<p>A binary filter needs to implement the <code>run</code> method, which takes a File argument and returns a File object. The returned File object should be a reference to a new file. The File argument should not be modified (otherwise the original asset will be changed).</p>
</div>

<div class="section" id="writing-routers">
	<h3><span>Writing Routers</span></h3>

	<p>Routers inherit from <code>Nanoc::Router</code> and must implement the <code>path_for_page_rep</code> and <code>path_for_asset_rep</code> methods. The former takes a page representation (<code>Nanoc::PageRep</code>) as an argument while the second takes an asset representation (<code>Nanoc::AssetRep</code>). The methods should return the output path of the given representation, starting with a slash representing the web root. Also see the <a href="/help/rdoc/classes/Nanoc/Router.html">RDoc documentation for <code>Nanoc::Router</code></a>.</p>

	<p>For example, this is the default router's implementation of <code>path_for_asset_rep</code>:</p>

	<pre><code><span class="keyword">def</span> <span class="function">path_for_asset_rep</span>(<span class="variable">asset_rep</span>)
  <span class="comment"># Get data we need</span>
  <span class="variable">extension</span>     = <span class="variable">asset_rep</span>.<span class="function">attribute_named</span>(<span class="symbol">:extension</span>)
  <span class="variable">modified_path</span> = <span class="variable">asset_rep</span>.<span class="function">asset</span>.<span class="function">path</span>[<span class="constant">0</span>..<span class="constant">-2</span>]
  <span class="variable">version</span>       = <span class="variable">asset_rep</span>.<span class="function">attribute_named</span>(<span class="symbol">:version</span>)

  <span class="comment"># Initialize path</span>
  <span class="variable">assets_prefix</span> = <span class="variable">@site</span>.<span class="function">config</span>[<span class="symbol">:assets_prefix</span>] || <span class="string">'/assets'</span>
  <span class="variable">path</span> = <span class="variable">assets_prefix</span> + <span class="variable">modified_path</span>

  <span class="comment"># Add rep name if necessary</span>
  <span class="keyword">unless</span> <span class="variable">asset_rep</span>.<span class="function">name</span> == <span class="symbol">:default</span>
    <span class="variable">path</span> += <span class="string">'-'</span> + <span class="variable">asset_rep</span>.<span class="function">name</span>.<span class="function">to_s</span>
  <span class="keyword">end</span>

  <span class="comment"># Add extension</span>
  <span class="variable">path</span> += <span class="string">'.'</span> + <span class="variable">extension</span>

  <span class="comment"># Done</span>
  <span class="variable">path</span>
<span class="keyword">end</span></code></pre>
</div>

<div class="section" id="writing-layout-processors">
	<h3><span>Writing Layout Processors</span></h3>

	<p>As of nanoc 2.1, layout processors are filters, so there is no need to write separate layout processorsâ€”simply write a filter and use that one.</p>
</div>
